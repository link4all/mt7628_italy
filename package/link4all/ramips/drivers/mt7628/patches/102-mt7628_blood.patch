diff -Nru old/src/chips/mt7628.c new/src/chips/mt7628.c
--- old/src/chips/mt7628.c	2016-03-10 11:11:56.000000000 +0800
+++ new/src/chips/mt7628.c	2019-03-08 20:46:36.000000000 +0800
@@ -1191,7 +1191,9 @@
 	}
 	else
 	{
+		
 		macVal = 0xD7083F0F;  //EDCCA OFF //d7083f0f		
+		//macVal = 0xD7e87d10;
 		RTMP_IO_WRITE32(pAd, WF_PHY_BASE + 0x0618, macVal);
 
 		macVal2 &= 0xFFFFFFFE;
diff -Nru old/src/embedded/ap/ap.c new/src/embedded/ap/ap.c
--- old/src/embedded/ap/ap.c	2016-03-10 11:12:00.000000000 +0800
+++ new/src/embedded/ap/ap.c	2019-03-08 20:46:36.000000000 +0800
@@ -2629,6 +2629,9 @@
 		pAd->CommonCfg.AddHTInfo.AddHtInfo.ExtChanOffset = 0;
 		pAd->CommonCfg.LastBSSCoexist2040.field.BSS20WidthReq = 1;
 		pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_SYNC;
+#ifdef NEW_BW2040_COEXIST_SUPPORT
+		pAd->CommonCfg.RegTransmitSetting.field.BW = 0;
+#endif
 	}
 
 	return;
diff -Nru old/src/embedded/ap/ap_cfg.c new/src/embedded/ap/ap_cfg.c
--- old/src/embedded/ap/ap_cfg.c	2016-03-10 11:12:00.000000000 +0800
+++ new/src/embedded/ap/ap_cfg.c	2019-03-08 20:46:36.000000000 +0800
@@ -521,6 +521,7 @@
 #endif /* EXT_BUILD_CHANNEL_LIST */
 	{"SSID",						Set_AP_SSID_Proc},
 	{"WirelessMode",				Set_WirelessMode_Proc},
+	{"MaxTxPwr",				Set_MaxTxPwr_Proc},
 	{"BasicRate",					Set_BasicRate_Proc},
 	{"ShortSlot",					Set_ShortSlot_Proc},
 	{"Channel",					Set_Channel_Proc},
@@ -871,6 +872,16 @@
 	{"PreAntSwitchTimeout",		    Set_PreAntSwitchTimeout_Proc},
 #endif /* PRE_ANT_SWITCH */
 
+#ifdef MT_MAC
+#ifdef DBG
+	{"FixedRate",				Set_Fixed_Rate_Proc},
+#endif /* DBG */
+#endif /* MT_MAC */
+#ifdef ANTI_INTERFERENCE_SUPPORT
+	{"DynamicRaInterval",		Set_DynamicRaInterval},
+	{"SwiftTrainThrd", 			Set_SwiftTrainThrd},
+#endif /* ANTI_INTERFERENCE_SUPPORT */
+
 #ifdef CFO_TRACK
 	{"CFOTrack",				Set_CFOTrack_Proc},
 #endif /* CFO_TRACK */
@@ -7152,6 +7163,8 @@
 	INT i;
 
 	printk("\n");
+	//UCHAR temp_str[20];
+	//INT temp_len = sizeof(temp_str);
 #ifdef DOT11_N_SUPPORT
 	printk("HT Operating Mode : %d\n", pAd->CommonCfg.AddHTInfo.AddHtInfo2.OperaionMode);
 	printk("\n");
@@ -7160,6 +7173,8 @@
 	printk("\n%-19s%-4s%-12s%-12s%-12s%-12s\n",
 		   "MAC", "AID","TxPackets","RxPackets","TxBytes","RxBytes");
 
+		printk("\n%-19s%-4s%-12s%-12s%-12s%-12s%-12s%-12s\n",
+		   "MAC", "AID","TxPackets","RxPackets","TxBytes","RxBytes", "TP(Tx)", "TP(Rx)");
 	for (i=0; i<MAX_LEN_OF_MAC_TABLE; i++)
 	{
 		PMAC_TABLE_ENTRY pEntry = &pAd->MacTab.Content[i];
@@ -7174,6 +7189,12 @@
 			printk("%-12ld", (ULONG)pEntry->RxPackets.QuadPart);
 			printk("%-12ld", (ULONG)pEntry->TxBytes);
 			printk("%-12ld", (ULONG)pEntry->RxBytes);
+
+			//snprintf(temp_str,temp_len,"%lu%s", (pEntry->AvgTxBytes >> 17), "Mbps");/* (n Bytes x 8) / (1024*1024) = (n >> 17) */
+			//printk("%-12s", temp_str);
+			//snprintf(temp_str,temp_len,"%lu%s", (pEntry->AvgRxBytes >> 17), "Mbps");/* (n Bytes x 8) / (1024*1024) = (n >> 17) */
+			//printk("%-12s", temp_str);
+			
 			printk("\n");
 		}
 	}
@@ -9392,6 +9413,10 @@
 		sprintf(msg+strlen(msg), "TX AGG Range 4 (>15)            = %ld\n", (LONG)(pAd->WlanCounters.TxAggRange4Count.u.LowPart));
 		{
 			ULONG mpduTXCount;
+#ifdef ANTI_INTERFERENCE_SUPPORT
+						UINT32 ampdu_fail_cnt;
+						UINT32 ampdu_fail_ratio;
+#endif /* ANTI_INTERFERENCE_SUPPORT */
 
 			mpduTXCount = pAd->WlanCounters.AmpduSuccessCount.u.LowPart;
 
@@ -9401,6 +9426,14 @@
 			sprintf(msg+strlen(msg), "AMPDU Tx fail count             = %ld, PER=%ld.%1ld%%\n",
 										(ULONG)pAd->WlanCounters.AmpduFailCount.u.LowPart,
 										per/10, per % 10);
+
+#ifdef ANTI_INTERFERENCE_SUPPORT
+						ampdu_fail_cnt = pAd->RalinkCounters.OneSecTxAMpduCnt - pAd->RalinkCounters.OneSecTxBACnt;
+						ampdu_fail_ratio = (ampdu_fail_cnt * 100) / pAd->RalinkCounters.OneSecTxAMpduCnt;
+						sprintf(msg+strlen(msg), "AMPDU Fail Ratio(No BA)		  = %d%% (%d/%d)\n", 
+								ampdu_fail_ratio, ampdu_fail_cnt, pAd->RalinkCounters.OneSecTxAMpduCnt);
+#endif /* ANTI_INTERFERENCE_SUPPORT */
+
 		}
 
         if (pAd->CommonCfg.bTXRX_RXV_ON) {
diff -Nru old/src/embedded/common/action.c new/src/embedded/common/action.c
--- old/src/embedded/common/action.c	2016-03-10 11:11:58.000000000 +0800
+++ new/src/embedded/common/action.c	2019-03-08 20:46:36.000000000 +0800
@@ -997,6 +997,10 @@
 						
 						NdisMoveMemory((PUCHAR)&pAd->CommonCfg.LastBSSCoexist2040, (PUCHAR)pBssCoexistIe, sizeof(BSS_2040_COEXIST_IE));
 						pAd->CommonCfg.Bss2040CoexistFlag |= BSS_2040_COEXIST_INFO_SYNC;
+						
+#ifdef NEW_BW2040_COEXIST_SUPPORT
+												bbp_set_bw(pAd, BW_20);/* radio fall back */
+#endif
 
 						if (!(pAd->CommonCfg.Bss2040CoexistFlag & BSS_2040_COEXIST_TIMER_FIRED))
 						{	
diff -Nru old/src/embedded/common/ba_action.c new/src/embedded/common/ba_action.c
--- old/src/embedded/common/ba_action.c	2016-03-10 11:11:56.000000000 +0800
+++ new/src/embedded/common/ba_action.c	2019-03-08 20:46:36.000000000 +0800
@@ -1658,6 +1658,7 @@
 {
 	struct reordering_mpdu *mpdu_blk;
 	UINT16	Sequence = (UINT16) pRxBlk->pHeader->Sequence;
+	LONG Now32;
 
 	mpdu_blk = ba_mpdu_blk_alloc(pAd);
 	if ((mpdu_blk != NULL) &&
@@ -1704,8 +1705,19 @@
 	}
 	else
 	{
-		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, DBG_LVL_ERROR,  ("!!! (%d) Can't allocate reordering mpdu blk\n",
-								   pBAEntry->list.qlen));
+#if 0
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, DBG_LVL_ERROR,  ("!!! (%d:%d) Can't allocate reordering mpdu blk\n",
+										   blk_count, pBAEntry->list.qlen));
+#else
+				if (mpdu_blk)
+					ba_mpdu_blk_free(pAd, mpdu_blk);//mem leak
+				else {
+					MTWF_LOG(DBG_CAT_PROTO, CATPROTO_BA, DBG_LVL_ERROR,  ("!!! (used:%d/free:%d) Can't allocate reordering mpdu blk\n",
+							 pBAEntry->list.qlen, pAd->mpdu_blk_pool.freelist.qlen));
+				}
+		
+#endif
+
 		/* 
 		 * flush all pending reordering mpdus 
 		 * and receving mpdu to upper layer
@@ -1716,6 +1728,15 @@
 
 		pBAEntry->LastIndSeq = Sequence;
 		INDICATE_LEGACY_OR_AMSDU(pAd, pRxBlk, wdev_idx);
+		//继续依续上抛
+		Sequence = ba_indicate_reordering_mpdus_in_order(pAd, pBAEntry, pBAEntry->LastIndSeq);
+
+		if (Sequence != RESET_RCV_SEQ) {
+			pBAEntry->LastIndSeq = Sequence;
+		}
+		//更新LastIndSeqAtTimer
+		NdisGetSystemUpTime(&Now32);
+		pBAEntry->LastIndSeqAtTimer = Now32;
 	}
 }
 
diff -Nru old/src/embedded/common/cmm_data.c new/src/embedded/common/cmm_data.c
--- old/src/embedded/common/cmm_data.c	2016-03-10 11:11:56.000000000 +0800
+++ new/src/embedded/common/cmm_data.c	2019-03-08 20:46:36.000000000 +0800
@@ -284,6 +284,11 @@
         RxBlk->rxv2_cyc2 = *(UINT32 *)RXV2_2ND_CYCLE;
         RxBlk->rxv2_cyc3 = *(UINT32 *)RXV2_3TH_CYCLE;
         pAd->rxv2_cyc3[(DW1->RxvSn % 10)] = RxBlk->rxv2_cyc3;
+				{
+			MAC_TABLE_ENTRY *pEntry = MacTableLookup(pAd, Data);
+			if (pEntry != NULL)
+				pEntry->rxv2_cyc3[(DW1->RxvSn % 10)] = RxBlk->rxv2_cyc3;	
+		}
 #ifdef CONFIG_QA
 	pAd->ATECtrl.RCPI0 = RXV1_3TH_CYCLE->Rcpi0;
 	pAd->ATECtrl.RCPI1 = RXV1_3TH_CYCLE->Rcpi1;
diff -Nru old/src/embedded/common/cmm_info.c new/src/embedded/common/cmm_info.c
--- old/src/embedded/common/cmm_info.c	2016-03-10 11:11:56.000000000 +0800
+++ new/src/embedded/common/cmm_info.c	2019-03-08 20:46:36.000000000 +0800
@@ -345,6 +345,23 @@
 	return Set_Cmm_WirelessMode_Proc(pAd, arg, 0);
 }
 
+INT Set_MaxTxPwr_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg)
+{	
+	UCHAR MaxTxPwr = 0;
+	
+	MaxTxPwr = (UCHAR) simple_strtol(arg, 0, 10);
+
+	if( (MaxTxPwr>0) && (MaxTxPwr < 0xff))
+	{
+		pAd->MaxTxPwr = MaxTxPwr;
+		BuildChannelList(pAd);
+		return TRUE;
+	}
+	
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("ERROR: wrong power announced(MaxTxPwr=%d)\n", MaxTxPwr));
+	return FALSE;
+	
+}
 
 
 
@@ -4995,6 +5012,262 @@
 }
 #endif /* PRE_ANT_SWITCH */
 
+#ifdef MT_MAC
+#ifdef DBG
+
+UINT8 raStbcSettingCheck(
+    UINT8 ucOrigStbc,
+    UINT8 ucMode,
+    UINT8 ucMcs,
+    UINT8 ucVhtNss,
+    BOOLEAN fgBFOn,
+    BOOLEAN fgForceOneTx
+    )
+{
+    UINT8 ucStbc = 0;
+
+    if (fgForceOneTx == TRUE)
+    {
+        return ucStbc;
+    }
+
+    if (fgBFOn == TRUE)
+    {
+        return ucStbc;
+    }
+
+    switch(ucMode)
+    {
+        case MODE_VHT:
+            if (ucVhtNss == 1)
+            {
+                ucStbc = ucOrigStbc;
+            }
+            else
+            {
+                ucStbc = 0;
+            }
+            break;
+        case MODE_HTMIX:
+        case MODE_HTGREENFIELD:
+            if (ucMcs < MCS_8)
+            {
+                ucStbc = ucOrigStbc;
+            }
+            else
+            {
+                ucStbc = 0;
+            }
+            break;
+        case MODE_CCK:
+        case MODE_OFDM:
+        default:
+            ucStbc = 0;
+            break;
+    }
+
+    return ucStbc;
+}
+
+INT Set_Fixed_Rate_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg)
+{
+	BOOLEAN fgStatus = TRUE;
+	UINT32 ret;
+	INT32 i4Recv = 0;
+	UINT32 u4WCID = 0;
+	UINT32 u4Mode = 0, u4Bw = 0, u4Mcs = 0, u4VhtNss = 0;
+	UINT32 u4SGI = 0, u4Preamble = 0, u4STBC = 0, u4LDPC = 0, u4SpeEn = 0;
+	MAC_TABLE_ENTRY *pEntry = NULL;
+
+	if (arg)
+	{
+		do
+        {
+			i4Recv = sscanf(arg, "%d-%d-%d-%d-%d-%d-%d-%d-%d-%d", &(u4WCID),
+							&(u4Mode), &(u4Bw), &(u4Mcs), &(u4VhtNss),
+							&(u4SGI), &(u4Preamble), &(u4STBC), &(u4LDPC), &(u4SpeEn));
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE, ("%s():WCID = %d, Mode = %d, BW = %d, MCS = %d, VhtNss = %d\n"
+					"\t\t\t\tSGI = %d, Preamble = %d, STBC = %d, LDPC = %d, SpeEn = %d\n",
+					__FUNCTION__, u4WCID, u4Mode, u4Bw, u4Mcs, u4VhtNss,
+					u4SGI, u4Preamble, u4STBC, u4LDPC, u4SpeEn));
+
+			if (i4Recv != 10)
+			{
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Format Error!\n"));
+				fgStatus = FALSE;
+				break;
+			}
+
+			/*if (!VALID_UCAST_ENTRY_WCID(u4WCID))
+			{
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("WCID exceed pAd->MaxUcastEntryNum!\n"));
+				fgStatus = FALSE;
+				break;
+			}*/
+
+			if (u4Mode > MODE_VHT)
+			{
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Unknow Mode!\n"));
+				fgStatus = FALSE;
+				break;
+			}
+
+			if (u4Bw > 4)
+			{
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Unknow BW!\n"));
+				fgStatus = FALSE;
+				break;
+			}
+
+			if (((u4Mode == MODE_CCK) && (u4Mcs > 3)) ||
+					((u4Mode == MODE_OFDM) && (u4Mcs > 7))||
+					((u4Mode == MODE_HTMIX) && (u4Mcs > 32))||
+					((u4Mode == MODE_VHT) && (u4Mcs > 9)))
+			{
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Unknow MCS!\n"));
+				fgStatus = FALSE;
+				break;
+			}
+
+			if ((u4Mode == MODE_VHT) && (u4VhtNss > 4))
+			{
+				MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Unknow VhtNss!\n"));
+				fgStatus = FALSE;
+				break;
+			}
+
+			RTMP_SEM_EVENT_WAIT(&pAd->AutoRateLock, ret);
+
+			pEntry = &pAd->MacTab.Content[u4WCID];
+
+			if (IS_ENTRY_NONE(pEntry))
+			{
+				RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
+				break;
+			}
+
+			u4STBC = raStbcSettingCheck(u4STBC, u4Mode, u4Mcs, u4VhtNss, 0, 0);
+
+			pEntry->HTPhyMode.field.MODE = u4Mode;
+			pEntry->HTPhyMode.field.iTxBF = 0;
+			pEntry->HTPhyMode.field.eTxBF = 0;
+			pEntry->HTPhyMode.field.STBC = u4STBC?1:0;
+			pEntry->HTPhyMode.field.ShortGI = u4SGI?1:0;
+			pEntry->HTPhyMode.field.BW = u4Bw;
+			pEntry->HTPhyMode.field.ldpc = u4LDPC?1:0;
+			pEntry->HTPhyMode.field.MCS = u4Mcs;
+
+			pEntry->LastTxRate = pEntry->HTPhyMode.word;
+			pAd->LastTxRate = pEntry->HTPhyMode.word;
+
+#ifdef CONFIG_STA_SUPPORT
+			IF_DEV_CONFIG_OPMODE_ON_STA(pAd)
+			{
+				pAd->StaCfg.wdev.bAutoTxRateSwitch = FALSE;
+			}
+#endif /* CONFIG_STA_SUPPORT */
+
+#ifdef CONFIG_AP_SUPPORT
+			IF_DEV_CONFIG_OPMODE_ON_AP(pAd)
+			{
+				pEntry->wdev->bAutoTxRateSwitch = FALSE;
+			}
+#endif /* CONFIG_AP_SUPPORT */
+
+			pEntry->bAutoTxRateSwitch = FALSE;
+
+#ifdef MCS_LUT_SUPPORT
+			AsicMcsLutUpdate(pAd, pEntry);
+			pEntry->LastTxRate = (USHORT) (pEntry->HTPhyMode.word);
+#endif /* MCS_LUT_SUPPORT */
+
+			RTMP_SEM_EVENT_UP(&pAd->AutoRateLock);
+		} while (0);
+	}
+
+	if (fgStatus == FALSE)
+	{
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("iwpriv ra0 set FixedRate=[WCID]-[Mode]-[BW]-[MCS]-[VhtNss]-[SGI]-[Preamble]-[STBC]-[LDPC]-[SPE_EN]\n"));
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("[WCID]Wireless Client ID\n"));
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("[Mode]CCK=0, OFDM=1, HT=2, GF=3, VHT=4\n"));
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("[BW]BW20=0, BW40=1, BW80=2,BW160=3\n"));
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("[MCS]CCK=0~4, OFDM=0~7, HT=0~32, VHT=0~9\n"));
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("[VhtNss]VHT=1~4, Other=ignore\n"));
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("[Preamble]Long=0, Other=Short\n"));
+	}
+	else
+	{
+		dump_wtbl_info(pAd, u4WCID);
+	}
+
+	return fgStatus;
+}
+#endif
+
+#ifdef ANTI_INTERFERENCE_SUPPORT
+INT Set_DynamicRaInterval(RTMP_ADAPTER *pAd, RTMP_STRING *arg)
+{
+	ULONG irqFlags = 0;
+	ULONG bDynamicRaInterval;
+
+	bDynamicRaInterval = simple_strtol(arg, 0, 10);
+
+	if (bDynamicRaInterval == 0) {
+		pAd->bDynamicRaInterval = FALSE;
+		RTMP_IRQ_LOCK(&pAd->irq_lock, irqFlags);
+		pAd->ra_interval = DEF_RA_TIME_INTRVAL;
+		pAd->ra_fast_interval = DEF_QUICK_RA_TIME_INTERVAL;
+
+#ifdef CONFIG_AP_SUPPORT
+		if (pAd->ApCfg.ApQuickResponeForRateUpTimerRunning == TRUE) {
+			BOOLEAN Cancelled;
+
+			RTMPCancelTimer(&pAd->ApCfg.ApQuickResponeForRateUpTimer, &Cancelled);	
+			pAd->ApCfg.ApQuickResponeForRateUpTimerRunning = FALSE;
+		}
+#endif /* CONFIG_AP_SUPPORT  */
+		RTMP_IRQ_UNLOCK(&pAd->irq_lock, irqFlags);
+	} else
+		pAd->bDynamicRaInterval = TRUE;
+
+    MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, DBG_LVL_OFF, ("%s()::bDynamicRaInterval=%d\n",
+				__FUNCTION__, pAd->bDynamicRaInterval));
+
+	return TRUE;
+}
+
+INT Set_SwiftTrainThrd(RTMP_ADAPTER *pAd, RTMP_STRING *arg)
+{
+	BOOLEAN fgStatus = TRUE;
+	INT32 i4Recv = 0;
+	UINT32 u4WCID = 0, u4SwiftTrainThrd = 0;
+	MAC_TABLE_ENTRY *pEntry = NULL;
+
+	if(arg){
+		i4Recv = sscanf(arg, "%d-%d", &(u4WCID), &(u4SwiftTrainThrd));
+		MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_TRACE,
+				("%s():WCID = %d, SwiftTrainThrd = %d\n",__FUNCTION__, u4WCID, u4SwiftTrainThrd));
+		
+		if (i4Recv != 2) {
+			MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_ERROR, ("Format Error!\n"));
+			fgStatus = FALSE;
+			return fgStatus;
+		}
+		pEntry = &pAd->MacTab.Content[u4WCID];
+
+		if (!IS_ENTRY_NONE(pEntry))
+			pEntry->SwiftTrainThrd = u4SwiftTrainThrd;
+	}
+
+    MTWF_LOG(DBG_CAT_CFG, DBG_SUBCAT_ALL, DBG_LVL_OFF, ("%s()::SwiftTrainThrd=%d\n",
+				__FUNCTION__, pEntry->SwiftTrainThrd));
+
+	return fgStatus;
+}
+
+#endif /* ANTI_INTERFERENCE_SUPPORT */
+
+#endif
 
 
 
diff -Nru old/src/embedded/common/cmm_sync.c new/src/embedded/common/cmm_sync.c
--- old/src/embedded/common/cmm_sync.c	2016-03-10 11:11:58.000000000 +0800
+++ new/src/embedded/common/cmm_sync.c	2019-03-08 20:46:36.000000000 +0800
@@ -117,7 +117,9 @@
 						if (N_ChannelGroupCheck(pAd, pAd->ChannelList[index + i].Channel))
 							pAd->ChannelList[index + i].Flags |= CHANNEL_40M_CAP;
 #endif /* DOT11_N_SUPPORT */
-
+								if (strncmp(pAd->CommonCfg.CountryCode, "CN", 2) == 0)
+					pAd->ChannelList[index+i].MaxTxPwr = pAd->MaxTxPwr;
+				else
 				pAd->ChannelList[index+i].MaxTxPwr = 20;
 			}
 
diff -Nru old/src/embedded/common/mlme.c new/src/embedded/common/mlme.c
--- old/src/embedded/common/mlme.c	2016-03-10 11:11:56.000000000 +0800
+++ new/src/embedded/common/mlme.c	2019-03-08 20:46:36.000000000 +0800
@@ -1895,6 +1895,11 @@
 		NICUpdateRawCounters(pAd);
 		RTMP_SECOND_CCA_DETECTION(pAd);
 
+#ifdef ANTI_INTERFERENCE_SUPPORT
+		if (pAd->bDynamicRaInterval)
+			DynamicRaInterval(pAd);
+#endif /* ANTI_INTERFERENCE_SUPPORT */
+
 #ifdef DYNAMIC_VGA_SUPPORT
 		dynamic_vga_adjust(pAd);
 #endif /* DYNAMIC_VGA_SUPPORT */
diff -Nru old/src/embedded/common/rtmp_init.c new/src/embedded/common/rtmp_init.c
--- old/src/embedded/common/rtmp_init.c	2016-03-10 11:11:58.000000000 +0800
+++ new/src/embedded/common/rtmp_init.c	2019-03-08 20:46:36.000000000 +0800
@@ -1858,6 +1858,7 @@
 
 	pAd->RxAnt.Pair1PrimaryRxAnt = 0;
 	pAd->RxAnt.Pair1SecondaryRxAnt = 1;
+	pAd->MaxTxPwr = 27;
 
 		pAd->RxAnt.EvaluatePeriod = 0;
 		pAd->RxAnt.RcvPktNumWhenEvaluate = 0;
@@ -2069,7 +2070,7 @@
 #endif /* DATA_QUEUE_RESERVE */
     pAd->bPS_Retrieve =1;
 
-	pAd->CommonCfg.bTXRX_RXV_ON = 0;
+	pAd->CommonCfg.bTXRX_RXV_ON = 1;
 
     pAd->CommonCfg.ManualTxop = 0;
 
@@ -2086,6 +2087,9 @@
 	pAd->SCSCtrl.SCSStatus=SCS_STATUS_DEFAULT;
 	pAd->SCSCtrl.SCSThreshold = 250000; /* 2 Mbps */
 #endif
+#ifdef ANTI_INTERFERENCE_SUPPORT
+		pAd->bDynamicRaInterval = FALSE;
+#endif
 
 	pAd->ed_chk = FALSE; //let country region to turn on
 	pAd->ed_debug = FALSE;
diff -Nru old/src/embedded/include/dot11_base.h new/src/embedded/include/dot11_base.h
--- old/src/embedded/include/dot11_base.h	2016-03-10 11:12:00.000000000 +0800
+++ new/src/embedded/include/dot11_base.h	2019-03-08 20:46:36.000000000 +0800
@@ -146,6 +146,6 @@
 #define SIFS_TIME_5G		16
 
 #define RIFS_TIME		2	//802.11n
-#define EIFS_TIME		360
+#define EIFS_TIME		84
 #endif /* _DOT11_BASE_H_ */
 
diff -Nru old/src/embedded/include/drs_extr.h new/src/embedded/include/drs_extr.h
--- old/src/embedded/include/drs_extr.h	2016-03-10 11:12:00.000000000 +0800
+++ new/src/embedded/include/drs_extr.h	2019-03-08 20:46:36.000000000 +0800
@@ -23,6 +23,9 @@
 #ifndef __DRS_EXTR_H__
 #define __DRS_EXTR_H__
 
+#define SWIFT_TRAIN_UP 1
+#define CCK_TRAIN_UP 1
+
 struct _RTMP_ADAPTER;
 struct _MAC_TABLE_ENTRY;
 
@@ -34,6 +37,9 @@
 #define TX_RATE_INDEX_678	5
 #define TX_COUNTER_OVERFLOW	0xFF
 
+#define RA_PROBING_ABORT_TX_CNT             15
+#define RA_PROBING_ABORT_CCK_TX_CNT         3
+
 typedef struct _RTMP_TX_RATE {
 	UCHAR mode;
 	UCHAR bw;
@@ -341,6 +347,8 @@
 #ifdef MT_MAC
 VOID DynamicTxRateSwitchingAdaptMT(struct _RTMP_ADAPTER *pAd, UINT idx);
 VOID QuickResponeForRateUpExecAdaptMT(struct _RTMP_ADAPTER *pAd, UINT idx); 
+VOID DynamicRaInterval(struct _RTMP_ADAPTER *pAd);
+
 #endif /* MT_MAC */
 
 #ifdef CONFIG_AP_SUPPORT
@@ -412,6 +420,8 @@
 	IN UCHAR *pTableSize,
 	IN UCHAR *pInitTxRateIdx);
 
+void ra_swift_train_up_table_reset(struct _MAC_TABLE_ENTRY *pEntry);
+
 /* normal rate switch */
 #define RTMP_DRS_ALG_INIT(__pAd, __Alg)										\
 	(__pAd)->rateAlg = __Alg;
diff -Nru old/src/embedded/include/mlme.h new/src/embedded/include/mlme.h
--- old/src/embedded/include/mlme.h	2016-03-10 11:12:00.000000000 +0800
+++ new/src/embedded/include/mlme.h	2019-03-08 20:46:36.000000000 +0800
@@ -202,6 +202,8 @@
 #define ERP_IS_USE_BARKER_PREAMBLE(x)    (((x) & 0x04) != 0)    /* 802.11g */
 
 #define DRS_TX_QUALITY_WORST_BOUND       8/* 3  // just test by gary */
+#define DRS_TX_QUALITY_HALF_BOUND		 4
+
 #define DRS_PENALTY                      8
 
 #define BA_NOTUSE 	2
diff -Nru old/src/embedded/include/os/rt_linux.h new/src/embedded/include/os/rt_linux.h
--- old/src/embedded/include/os/rt_linux.h	2016-03-10 11:12:00.000000000 +0800
+++ new/src/embedded/include/os/rt_linux.h	2019-03-08 20:46:36.000000000 +0800
@@ -802,25 +802,18 @@
 }
 
 #define MTWF_LOG(Category, SubCategory, Level, Fmt)	\
-do{	\
-	if ((Category) & DBG_CAT_EN_BITMAP) {	\
-		if ((Level) <= DBG_LVL_WARN) {	\
-			MTWF_PRINT Fmt;	\
-		} else if ((Category) & (DebugCategory)) {	\
-			if ((Level) <= DebugLevel) { \
-				if ((SubCategory) == DBG_SUBCAT_ALL)	\
-					MTWF_PRINT Fmt;	\
-				else {	\
-					ULONG bit = GET_BIT(Category);	\
-					if ((DebugSubCategory[bit] == DBG_SUBCAT_ALL) || \
-						((SubCategory) & DebugSubCategory[bit]))	\
-						MTWF_PRINT Fmt; \
-				}	\
-			}	\
-		}	\
-	}	\
+do{ 								  \
+	ULONG __gLevel = (Level) & 0xff;\
+	ULONG __fLevel = ((Level) & 0xffffff00);\
+	if (__gLevel <= DebugLevel)    \
+	{								\
+		if ((RTDebugFunc == 0) || \
+		((RTDebugFunc != 0) && (((__fLevel & RTDebugFunc)!= 0) || (__gLevel <= DBG_LVL_ERROR))))\
+		printk Fmt; 			  \
+	}								\
 }while(0)
 
+
 #define DBGPRINT_ERR(Fmt)           \
 {                                   \
     printk("ERROR!!! ");          \
diff -Nru old/src/embedded/include/rtmp_def.h new/src/embedded/include/rtmp_def.h
--- old/src/embedded/include/rtmp_def.h	2016-03-10 11:12:00.000000000 +0800
+++ new/src/embedded/include/rtmp_def.h	2019-03-08 20:46:36.000000000 +0800
@@ -1661,6 +1661,8 @@
 /*definition of DRS */
 #define MAX_TX_RATE_INDEX			33		/* Maximum Tx Rate Table Index value */
 
+#define SWIFT_TRAIN_UP_RECORD		8
+
 /* pre-allocated free NDIS PACKET/BUFFER poll for internal usage */
 #define MAX_NUM_OF_FREE_NDIS_PACKET 128
 
diff -Nru old/src/embedded/include/rtmp.h new/src/embedded/include/rtmp.h
--- old/src/embedded/include/rtmp.h	2016-03-10 11:11:58.000000000 +0800
+++ new/src/embedded/include/rtmp.h	2019-03-08 20:46:36.000000000 +0800
@@ -816,6 +816,11 @@
 	UINT32 OneSecRxARalinkCnt;	/* Rx Ralink Aggregation frame cnt */
 	UINT32 OneSecEnd;	/* for one sec count clear use */
 
+	#ifdef ANTI_INTERFERENCE_SUPPORT
+	UINT32 OneSecTxAMpduCnt;
+	UINT32 OneSecTxBACnt;
+#endif /* ANTI_INTERFERENCE_SUPPORT */
+
 	ULONG TransmittedByteCount;	/* both successful and failure, used to calculate TX throughput */
 	ULONG ReceivedByteCount;	/* both CRC okay and CRC error, used to calculate RX throughput */
 	ULONG BadCQIAutoRecoveryCount;
@@ -2897,7 +2902,7 @@
 	struct wifi_dev *wdev;
 	PVOID pAd;
 	struct _MAC_TABLE_ENTRY *pNext;
-
+	UINT32 rxv2_cyc3[10];
 	/*
 		A bitmap of BOOLEAN flags. each bit represent an operation status of a particular
 		BOOLEAN control, either ON or OFF. These flags should always be accessed via
@@ -3089,12 +3094,19 @@
 #endif /* AGS_SUPPORT */
 
 	/* to record the each TX rate's quality. 0 is best, the bigger the worse. */
-	USHORT TxQuality[MAX_TX_RATE_INDEX + 1];
+	UINT8 TxQuality[MAX_TX_RATE_INDEX + 1];
+#if (SWIFT_TRAIN_UP >= 1)
+		UINT8 SwiftTrainUpRate[SWIFT_TRAIN_UP_RECORD];
+		CHAR SwiftTrainUpRSSI[SWIFT_TRAIN_UP_RECORD];
+#endif	
+
 	BOOLEAN fLastSecAccordingRSSI;
 	UCHAR LastSecTxRateChangeAction;	/* 0: no change, 1:rate UP, 2:rate down */
 	CHAR LastTimeTxRateChangeAction;	/* Keep last time value of LastSecTxRateChangeAction */
 	ULONG LastTxOkCount; /* TxSuccess count in last Rate Adaptation interval */
 	UCHAR LastTxPER;	/* Tx PER in last Rate Adaptation interval */
+		BOOLEAN bSwiftTrain;
+	UINT32 SwiftTrainThrd;
 	UCHAR PER[MAX_TX_RATE_INDEX + 1];
 	UINT32 CurrTxRateStableTime;	/* # of second in current TX rate */
 	UCHAR TxRateUpPenalty;	/* extra # of second penalty due to last unstable condition */
@@ -4760,7 +4772,7 @@
 	/* ---------------------------- */
 	CHANNEL_TX_POWER TxPower[MAX_NUM_OF_CHANNELS];	/* Store Tx power value for all channels. */
 	CHANNEL_TX_POWER ChannelList[MAX_NUM_OF_CHANNELS];	/* list all supported channels for site survey */
-
+	UCHAR MaxTxPwr;//announced in beacon 
 
 
 	UCHAR ChannelListNum;	/* number of channel in ChannelList[] */
@@ -5423,6 +5435,11 @@
 	UINT32 ch_busy_stat[ED_STAT_CNT];
 	INT32 rssi_stat[ED_STAT_CNT];
 	ULONG chk_time[ED_STAT_CNT];
+	
+	#ifdef ANTI_INTERFERENCE_SUPPORT
+	BOOLEAN bDynamicRaInterval;
+	char ra_interval_extend;
+#endif /* ANTI_INTERFERENCE_SUPPORT */
 #ifdef DATA_QUEUE_RESERVE
 	BOOLEAN bQueueRsv;
 	BOOLEAN bDump;
@@ -9373,6 +9390,8 @@
 INT Set_CountryRegion_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
 INT Set_CountryRegionABand_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
 INT Set_WirelessMode_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
+INT Set_MaxTxPwr_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
+
 INT Set_MBSS_WirelessMode_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
 INT Set_Channel_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
 INT	Set_ShortSlot_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
@@ -9452,6 +9471,16 @@
 #endif /* PRE_ANT_SWITCH */
 
 
+#ifdef MT_MAC
+#ifdef DBG
+INT Set_Fixed_Rate_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
+#endif /* DBG */
+#ifdef ANTI_INTERFERENCE_SUPPORT
+INT Set_DynamicRaInterval(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
+INT Set_SwiftTrainThrd(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
+#endif /* ANTI_INTERFERENCE_SUPPORT */
+
+#endif /* MT_MAC */
 
 #ifdef CFO_TRACK
 INT Set_CFOTrack_Proc(RTMP_ADAPTER *pAd, RTMP_STRING *arg);
diff -Nru old/src/embedded/sta/connect.c new/src/embedded/sta/connect.c
--- old/src/embedded/sta/connect.c	2016-03-10 11:11:58.000000000 +0800
+++ new/src/embedded/sta/connect.c	2019-03-11 10:35:06.139318300 +0800
@@ -2550,6 +2550,7 @@
 
 	pEntry->wdev = wdev;
 	wdev->allow_data_tx = TRUE;
+//	pEntry->SwiftTrainThrd = 10;
 	NdisReleaseSpinLock(&pAd->MacTabLock);
 
 	if (bDoTxRateSwitch == TRUE)
@@ -2580,6 +2581,9 @@
 
 	/*  Let Link Status Page display first initial rate. */
 	pAd->LastTxRate = (USHORT) (pEntry->HTPhyMode.word);
+//#if (SWIFT_TRAIN_UP >= 1)
+//		ra_swift_train_up_table_reset(pEntry);
+//#endif
 
 	AsicSetTxStream(pAd, pAd->Antenna.field.TxPath, OPMODE_STA, TRUE);
 
diff -Nru old/src/hw_ctrl/cmm_asic_mt.c new/src/hw_ctrl/cmm_asic_mt.c
--- old/src/hw_ctrl/cmm_asic_mt.c	2016-03-10 11:11:56.000000000 +0800
+++ new/src/hw_ctrl/cmm_asic_mt.c	2019-03-08 20:46:36.000000000 +0800
@@ -154,9 +154,11 @@
 
 	MAC_IO_READ32(pAd, AGG_ARCR, &Value);
 	Value |= INI_RATE1;
+	Value |= FB_SGI_DIS;
 	Value &= ~RTS_RATE_DOWN_TH_MASK;
+	Value |= RTS_RATE_DOWN_TH(2);
 	Value &= ~RATE_DOWN_EXTRA_RATIO_MASK;
-	Value |= RATE_DOWN_EXTRA_RATIO(1);
+	Value |= RATE_DOWN_EXTRA_RATIO(2);
 	Value |= RATE_DOWN_EXTRA_RATIO_EN;
 	Value &= ~RATE_UP_EXTRA_TH_MASK;
 	Value |= RATE_UP_EXTRA_TH(4);
@@ -3084,11 +3086,12 @@
 
 INT32 MtAsicSetMacTxRx(RTMP_ADAPTER *pAd, INT32 TxRx, BOOLEAN Enable)
 {
-	UINT32 Value, Value1, Value2;
+	UINT32 Value, Value1, Value2, Value3;
 
 	MAC_IO_READ32(pAd, ARB_SCR, &Value);
 	MAC_IO_READ32(pAd, ARB_TQCR0, &Value1);
 	MAC_IO_READ32(pAd, ARB_RQCR, &Value2);
+	MAC_IO_READ32(pAd, WF_PHY_BASE + 0x426c, &Value3);
 
 	switch (TxRx)
 	{
@@ -3138,6 +3141,8 @@
 				Value1 = 0xffffffff;
 				Value2 |= (ARB_RQCR_RX_START | ARB_RQCR_RXV_START |
 							ARB_RQCR_RXV_R_EN |	ARB_RQCR_RXV_T_EN);
+				Value3 &= 0xffffff0f;
+				Value3 |= 0x40;
 			}
 			else
 			{
@@ -3185,7 +3190,7 @@
 	MAC_IO_WRITE32(pAd, ARB_SCR, Value);
 	MAC_IO_WRITE32(pAd, ARB_TQCR0, Value1);
 	MAC_IO_WRITE32(pAd, ARB_RQCR, Value2);
-
+	MAC_IO_WRITE32(pAd, WF_PHY_BASE + 0x426c, Value3);
 	return TRUE;
 }
 
diff -Nru old/src/include/mac/mac_mt/smac/wf_agg.h new/src/include/mac/mac_mt/smac/wf_agg.h
--- old/src/include/mac/mac_mt/smac/wf_agg.h	2016-03-10 11:11:56.000000000 +0800
+++ new/src/include/mac/mac_mt/smac/wf_agg.h	2019-03-08 20:46:36.000000000 +0800
@@ -34,6 +34,8 @@
 
 #define AGG_ARCR			(WF_AGG_BASE + 0x010)	/* 0x21210 */
 #define INI_RATE1               (0x1 << 0)
+#define FB_SGI_DIS              (0x1 << 1)
+
 #define RTS_RATE_DOWN_TH_MASK	(0x1F << 8)
 #define RTS_RATE_DOWN_TH(p)		(((p) & 0x1F) << 8)
 #define RATE_DOWN_EXTRA_RATIO_MASK	(0x3 << 16)
diff -Nru old/src/include/phy/phy.h new/src/include/phy/phy.h
--- old/src/include/phy/phy.h	2016-03-10 11:11:56.000000000 +0800
+++ new/src/include/phy/phy.h	2019-03-08 20:46:36.000000000 +0800
@@ -42,6 +42,8 @@
 #include "phy/mt_rf.h"
 #endif
 
+#define ANTI_INTERFERENCE_SUPPORT
+
 /* value domain of pAd->RfIcType */
 #define RFIC_2820                   1       /* 2.4G 2T3R */
 #define RFIC_2850                   2       /* 2.4G/5G 2T3R */
diff -Nru old/src/mac/mt_mac.c new/src/mac/mt_mac.c
--- old/src/mac/mt_mac.c	2016-03-10 11:11:56.000000000 +0800
+++ new/src/mac/mt_mac.c	2019-03-08 20:46:36.000000000 +0800
@@ -416,6 +416,7 @@
 	UINT32 AmpduTxCount = 0;
 	UINT32 AmpduTxSuccessCount = 0;
 
+	COUNTER_RALINK	*pRalinkCounters = &pAd->RalinkCounters;
 
 	pPrivCounters = &pAd->RalinkCounters;
         wlanCounter = &pAd->WlanCounters;
@@ -443,6 +444,12 @@
 	bss_tx_cnt = (bss_tx_cnt >> 16) & 0xffff;
 #endif /* DBG_DIAGNOSE */
 
+#ifdef ANTI_INTERFERENCE_SUPPORT
+	RTMP_IO_READ32(pAd, MIB_MSDR12, &mac_val);
+	pRalinkCounters->OneSecTxAMpduCnt = mac_val & 0xFFFF;
+	pRalinkCounters->OneSecTxBACnt = (mac_val >> 16) & 0xFFFF;
+#endif /* ANTI_INTERFERENCE_SUPPORT */
+
 #ifdef STATS_COUNT_SUPPORT
 	pAd->WlanCounters.AmpduSuccessCount.u.LowPart += AmpduTxSuccessCount;
 	pAd->WlanCounters.AmpduFailCount.u.LowPart += (AmpduTxCount - AmpduTxSuccessCount);
diff -Nru old/build/Makefile new/build/Makefile
--- old/build/Makefile	2016-03-10 11:11:56.000000000 +0800
+++ new/build/Makefile	2019-03-08 20:46:50.000000000 +0800
@@ -65,7 +65,9 @@ cmm_objs := $(SRC_DIR)/common/crypt_md5.
 ########################################################
 rate_objs := $(SRC_DIR)/../rate_ctrl/ra_ctrl.o\
 						$(SRC_DIR)/../rate_ctrl/alg_legacy.o
-
+ifeq ($(CONFIG_MT7628_NEW_BW2040_COEXIST_SUPPORT),y)
+    EXTRA_CFLAGS +=-DNEW_BW2040_COEXIST_SUPPORT
+endif
 ifeq ($(CONFIG_NEW_RATE_ADAPT_SUPPORT),y)
     EXTRA_CFLAGS += -DNEW_RATE_ADAPT_SUPPORT
     rate_objs += $(SRC_DIR)/../rate_ctrl/alg_grp.o
diff -Nru old/src/rate_ctrl/alg_grp.c new/src/rate_ctrl/alg_grp.c
--- old/src/rate_ctrl/alg_grp.c	2016-03-10 11:12:00.000000000 +0800
+++ new/src/rate_ctrl/alg_grp.c	2019-03-08 20:46:36.000000000 +0800
@@ -592,6 +592,136 @@
 	return TxRateIdx;
 }
 
+#if (SWIFT_TRAIN_UP >= 1)
+void ra_swift_train_up_table_reset(MAC_TABLE_ENTRY *pEntry)
+{
+	UINT8 idx;
+
+	for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+		pEntry->SwiftTrainUpRate[idx] = 0;
+		pEntry->SwiftTrainUpRSSI[idx] = 0;
+	}
+}
+
+void ra_swift_train_up_table_update(MAC_TABLE_ENTRY *pEntry, CHAR rssi, UCHAR data_rate)
+{
+	UINT8 idx;
+	UINT8 head_gap, tail_gap;
+	INT j, k;
+
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Enter: (%d, %d)\n", rssi, data_rate));
+	for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("(%d, %d) ", pEntry->SwiftTrainUpRSSI[idx], pEntry->SwiftTrainUpRate[idx]));
+	}
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("\n"));
+
+	for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+		// Table already include RSSI record. 
+		if (pEntry->SwiftTrainUpRSSI[idx] == rssi) {
+			if (pEntry->SwiftTrainUpRate[idx] < data_rate) {
+				pEntry->SwiftTrainUpRate[idx] = data_rate;
+			}
+
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Exit:\n"));
+			for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("(%d, %d) ", pEntry->SwiftTrainUpRSSI[idx], pEntry->SwiftTrainUpRate[idx]));
+			}
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE| DBG_FUNC_RA), ("\n"));
+	
+			return;
+		}
+	}
+
+	for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+		if (pEntry->SwiftTrainUpRSSI[idx] == 0) {
+
+			for (j=0; j < idx; j++) {
+				if (pEntry->SwiftTrainUpRSSI[j] > rssi) {
+					break;
+				}
+			}
+
+			for (k = idx; k > j; k--) {
+				pEntry->SwiftTrainUpRSSI[k] = pEntry->SwiftTrainUpRSSI[k - 1];
+				pEntry->SwiftTrainUpRate[k] = pEntry->SwiftTrainUpRate[k - 1];
+			}
+
+			pEntry->SwiftTrainUpRSSI[j] = rssi;
+			pEntry->SwiftTrainUpRate[j] = data_rate;
+
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Exit:\n"));
+			for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("(%d, %d) ", pEntry->SwiftTrainUpRSSI[idx], pEntry->SwiftTrainUpRate[idx]));
+			}
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("\n"));
+
+			return;
+		}
+	}
+
+	head_gap = ABS(rssi , pEntry->SwiftTrainUpRSSI[0]);
+	tail_gap = ABS(rssi , pEntry->SwiftTrainUpRSSI[SWIFT_TRAIN_UP_RECORD - 1]);
+
+	if (head_gap > tail_gap) {
+		pEntry->SwiftTrainUpRSSI[0] = 0;
+		pEntry->SwiftTrainUpRate[0] = 0;
+
+		for (j=1; j < SWIFT_TRAIN_UP_RECORD; j++) {
+			if (pEntry->SwiftTrainUpRSSI[j] > rssi) {
+				break;
+			}
+		}
+		j--;
+
+		for (k = 0; k <= j; k++) {
+			pEntry->SwiftTrainUpRSSI[k] = pEntry->SwiftTrainUpRSSI[k + 1];
+			pEntry->SwiftTrainUpRate[k] = pEntry->SwiftTrainUpRate[k + 1];
+		}
+
+		pEntry->SwiftTrainUpRSSI[j] = rssi;
+		pEntry->SwiftTrainUpRate[j] = data_rate;
+	} else {
+		pEntry->SwiftTrainUpRSSI[SWIFT_TRAIN_UP_RECORD - 1] = 0;
+		pEntry->SwiftTrainUpRate[SWIFT_TRAIN_UP_RECORD - 1] = 0;
+
+		for (j=0; j < SWIFT_TRAIN_UP_RECORD - 1; j++) {
+			if (pEntry->SwiftTrainUpRSSI[j] > rssi) {
+				break;
+			}
+		}
+
+		for (k = SWIFT_TRAIN_UP_RECORD - 2; k >= j; k--) {
+			pEntry->SwiftTrainUpRSSI[k + 1] = pEntry->SwiftTrainUpRSSI[k];
+			pEntry->SwiftTrainUpRate[k + 1] = pEntry->SwiftTrainUpRate[k];
+		}
+
+		pEntry->SwiftTrainUpRSSI[j] = rssi;
+		pEntry->SwiftTrainUpRate[j] = data_rate;
+	}
+
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Exit:\n"));
+	for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("(%d, %d) ", pEntry->SwiftTrainUpRSSI[idx], pEntry->SwiftTrainUpRate[idx]));
+	}
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("\n"));
+
+}
+
+UCHAR ra_swift_train_up_table_query(MAC_TABLE_ENTRY *pEntry, CHAR rssi)
+{
+	UINT8 idx;
+
+	for (idx = 0; idx < SWIFT_TRAIN_UP_RECORD; idx++) {
+		// Table already include RSSI record. 
+		if (pEntry->SwiftTrainUpRSSI[idx] == rssi) {
+			return pEntry->SwiftTrainUpRate[idx];
+		}
+	}
+
+	return 0;
+}
+#endif/* SWIFT_TRAIN_UP */
+
 
 /*
 	MlmeRAHybridRule - decide whether to keep the new rate or use old rate
@@ -727,7 +857,7 @@
 	{
 		if (pEntry->LastSecTxRateChangeAction!=RATE_NO_CHANGE)
 		{
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: %sTX rate from %d to %d \n",
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: %sTX rate from %d to %d \n",
 				pEntry->LastSecTxRateChangeAction == RATE_UP? "++": "--", CurrRateIdx, pEntry->CurrTxRateIndex));
 		}
 
@@ -798,24 +928,51 @@
 	UCHAR *pTable = pEntry->pTable;
 	UCHAR CurrRateIdx = pEntry->CurrTxRateIndex;
 	RTMP_RA_GRP_TB *pCurrTxRate = PTX_RA_GRP_ENTRY(pTable, CurrRateIdx);
+#if (SWIFT_TRAIN_UP >= 1)
+		CHAR Rssi = RTMPAvgRssi(pAd, &pEntry->RssiSample);
+#endif
+		CHAR MaxRssi = RTMPMaxRssi(pAd, pEntry->RssiSample.AvgRssi[0], pEntry->RssiSample.AvgRssi[1], pEntry->RssiSample.AvgRssi[2]);
 
 	pEntry->LastSecTxRateChangeAction = RATE_NO_CHANGE;
 
 	if (Rate1ErrorRatio >= TrainDown)
 	{
 		/*  Downgrade TX quality if PER >= Rate-Down threshold */
-		MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND);
+		//MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND);
 
 		if (CurrRateIdx != DownRateIdx)
 		{
+#if 1
+			/*If MODE_HTMIX Mode but pCurrTxRate == MCS_3,not drop*/
+			if ((Rate1ErrorRatio != 100) && (MlmeGetTxQuality(pEntry, CurrRateIdx) < DRS_TX_QUALITY_HALF_BOUND))
+			{
+				pEntry->LastSecTxRateChangeAction = RATE_NO_CHANGE;
+				if (MlmeGetTxQuality(pEntry, pCurrTxRate->upMcs1) < DRS_TX_QUALITY_HALF_BOUND)
+					MlmeSetTxQuality(pEntry, pCurrTxRate->upMcs1, DRS_TX_QUALITY_HALF_BOUND);
+				if (MlmeGetTxQuality(pEntry, pCurrTxRate->upMcs2) < DRS_TX_QUALITY_HALF_BOUND)
+					MlmeSetTxQuality(pEntry, pCurrTxRate->upMcs2, DRS_TX_QUALITY_HALF_BOUND);
+				
+			}
+			else {
+					pEntry->CurrTxRateIndex = DownRateIdx;		
+				pEntry->LastSecTxRateChangeAction = RATE_DOWN;
+			}
+#else
 			pEntry->CurrTxRateIndex = DownRateIdx;
 			pEntry->LastSecTxRateChangeAction = RATE_DOWN;
+#endif
+			/*  Downgrade TX quality if PER >= Rate-Down threshold */
+			MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND);
+
 		}
 
 	} else {
 		if ( Rate1ErrorRatio <= TrainUp ) {
 			bTrainUp = TRUE;
 			MlmeDecTxQuality(pEntry, CurrRateIdx);  /*  quality very good in CurrRate */
+#if (SWIFT_TRAIN_UP >= 1)			
+						ra_swift_train_up_table_update(pEntry, Rssi, pCurrTxRate->dataRate);
+#endif /* SWIFT_TRAIN_UP */
 
 			if (pEntry->TxRateUpPenalty) /* always == 0, always go to else */
 				pEntry->TxRateUpPenalty --;
@@ -826,6 +983,61 @@
 					Note that UpRate may mot equal one of the MCS groups if MlmeSelectUpRate
 					skipped over a rate that is not valid for this configuration.
 				*/
+				
+								UCHAR loop = 1;
+#if (SWIFT_TRAIN_UP >= 1)
+								RTMP_RA_GRP_TB *pUpTxRate = PTX_RA_GRP_ENTRY(pTable, CurrRateIdx);
+								UCHAR record_data_rate = ra_swift_train_up_table_query(pEntry, Rssi);
+				
+								if (record_data_rate > pUpTxRate->dataRate) {
+									MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("  swift rate up(1): record_data_rate = %d, up_data_rate = %d\n", record_data_rate, pUpTxRate->dataRate));
+									loop ++;
+								}
+#endif /* SWIFT_TRAIN_UP */
+				
+								while (loop > 0)
+								{
+									MlmeDecTxQuality(pEntry, UpRateIdx);
+				
+									if (pCurrTxRate->upMcs3!=CurrRateIdx &&
+										pCurrTxRate->upMcs3!=UpRateIdx)
+										MlmeDecTxQuality(pEntry, pCurrTxRate->upMcs3);
+				
+									if (pCurrTxRate->upMcs2!=CurrRateIdx &&
+											pCurrTxRate->upMcs2!=UpRateIdx &&
+											pCurrTxRate->upMcs2!=pCurrTxRate->upMcs3)
+										MlmeDecTxQuality(pEntry, pCurrTxRate->upMcs2);
+				
+									if (pCurrTxRate->upMcs1!=CurrRateIdx &&
+											pCurrTxRate->upMcs1!=UpRateIdx &&
+											pCurrTxRate->upMcs1!=pCurrTxRate->upMcs3 &&
+											pCurrTxRate->upMcs1!=pCurrTxRate->upMcs2)
+										MlmeDecTxQuality(pEntry, pCurrTxRate->upMcs1);
+				
+									loop--;
+								}
+							}
+						}
+						else if (pEntry->mcsGroup > 0) /* even if TxErrorRatio > TrainUp */
+						{
+							/*	Moderate PER but some groups are not tried */
+							bTrainUp = TRUE;
+				
+							/* TxQuality[CurrRateIdx] must be decremented so that mcs won't decrease wrongly */
+							MlmeDecTxQuality(pEntry, CurrRateIdx);	/*	quality very good in CurrRate */
+							if (CurrRateIdx != UpRateIdx)
+								MlmeDecTxQuality(pEntry, UpRateIdx);	/*	may improve next UP rate's quality */
+						}
+#if (SWIFT_TRAIN_UP >= 1)
+						else
+						{
+							RTMP_RA_GRP_TB *pUpTxRate = PTX_RA_GRP_ENTRY(pTable, CurrRateIdx);
+							UCHAR record_data_rate = ra_swift_train_up_table_query(pEntry, Rssi);
+							
+							if(record_data_rate > pUpTxRate->dataRate)
+							{
+								MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("  swift rate up(2): record_data_rate = %d, up_data_rate = %d\n", record_data_rate, pUpTxRate->dataRate));
+
 				MlmeDecTxQuality(pEntry, UpRateIdx);
 
 				if (pCurrTxRate->upMcs3!=CurrRateIdx &&
@@ -844,21 +1056,39 @@
 					MlmeDecTxQuality(pEntry, pCurrTxRate->upMcs1);
 			}
 		}
-		else if (pEntry->mcsGroup > 0) /* even if TxErrorRatio > TrainUp */
-		{
-			/*  Moderate PER but some groups are not tried */
-			bTrainUp = TRUE;
+#endif /* SWIFT_TRAIN_UP */
+#if	CCK_TRAIN_UP
 
-			/* TxQuality[CurrRateIdx] must be decremented so that mcs won't decrease wrongly */
-			MlmeDecTxQuality(pEntry, CurrRateIdx);  /*  quality very good in CurrRate */
-			MlmeDecTxQuality(pEntry, UpRateIdx);    /*  may improve next UP rate's quality */
-		}
+/* CCK should train up to MCS0 */
+				if ((pCurrTxRate->Mode == MODE_CCK) && (pEntry->SupportRateMode >= SUPPORT_HT_MODE) &&
+					(MaxRssi > -92)) {
+					pEntry->CurrTxRateIndex = PTX_RA_GRP_ENTRY(pTable, 0)->ItemNo;
+					pEntry->LastSecTxRateChangeAction = RATE_UP;
+				} else
+#endif
 
 		/*  If UpRate is good then train up in current BF state */
 		if ((CurrRateIdx != UpRateIdx) && (MlmeGetTxQuality(pEntry, UpRateIdx) <= 0) && bTrainUp)
 		{
 			pEntry->CurrTxRateIndex = UpRateIdx;
 			pEntry->LastSecTxRateChangeAction = RATE_UP;
+		}else {/* Keep Rate , No RATE_UP -> try same phy rate */
+		
+			RTMP_RA_GRP_TB *pSameTxRate;
+			int sameRateIdx = 0;
+			
+			for (sameRateIdx = 0; sameRateIdx < RATE_TABLE_SIZE(pTable); sameRateIdx++) {
+				pSameTxRate = PTX_RA_GRP_ENTRY(pTable, sameRateIdx);
+				if ((CurrRateIdx != sameRateIdx ) && (pCurrTxRate->dataRate == pSameTxRate->dataRate) && 
+					(MlmeGetTxQuality(pEntry, sameRateIdx) <= MlmeGetTxQuality(pEntry, CurrRateIdx))) { 
+					pEntry->CurrTxRateIndex = pSameTxRate->ItemNo;
+					pEntry->LastSecTxRateChangeAction = RATE_UP;
+					MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),
+						("Keep Rate , No RATE_UP -> try same phy rate!\n"));
+					
+					break;
+				}
+			 }
 		}
 	}
 
@@ -874,7 +1104,7 @@
 	{
 		if (pEntry->LastSecTxRateChangeAction!=RATE_NO_CHANGE)
 		{
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: %sTX rate from %d to %d \n",
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: %sTX rate from %d to %d \n",
 				pEntry->LastSecTxRateChangeAction==RATE_UP? "++": "--", CurrRateIdx, pEntry->CurrTxRateIndex));
 		}
 
@@ -886,7 +1116,7 @@
 		/*  Update TxQuality */
 		if (pEntry->LastSecTxRateChangeAction == RATE_DOWN)
 		{
-			MlmeSetTxQuality(pEntry, pEntry->CurrTxRateIndex, 0);
+			MlmeSetTxQuality(pEntry, pEntry->CurrTxRateIndex, DRS_TX_QUALITY_HALF_BOUND);
 			pEntry->PER[pEntry->CurrTxRateIndex] = 0;
 		}
 
@@ -939,9 +1169,9 @@
 {
 	PUCHAR					pTable;
 	UCHAR					CurrRateIdx;
-	ULONG					TxErrorRatio = 0;
+	//ULONG					TxErrorRatio = 0;
 	MAC_TABLE_ENTRY			*pEntry;
-	RTMP_RA_GRP_TB *pCurrTxRate;
+	RTMP_RA_GRP_TB *pCurrTxRate, *pLastTxRate;
 	UCHAR					TrainDown;
 	CHAR					Rssi, ratio;
 	ULONG					OneSecTxNoRetryOKRationCount;
@@ -949,16 +1179,22 @@
 
 	MT_TX_COUNTER TxInfo;
 	//UCHAR HwAggRateIndex;
-	UCHAR Rate1ErrorRatio;
+	UCHAR Rate1ErrorRatio = 0, RetryRatio = 0;
 
 	UINT32 Rate1TxCnt, Rate1SuccessCnt, Rate1FailCount;
 	UINT32 TxTotalCnt;
+	UINT32 u4CurrEffectTPut, u4LastEffectTPut;
+	BOOLEAN bNoiseEnv;
 
 
 	pEntry = &pAd->MacTab.Content[idx]; /* point to information of the individual station */
 	pTable = pEntry->pTable;
 	TxTotalCnt = Rate1TxCnt = Rate1SuccessCnt = Rate1FailCount = 0;
 	Rate1ErrorRatio = 0;
+	/*  Remember the current rate */
+	CurrRateIdx = pEntry->CurrTxRateIndex;
+	pCurrTxRate = PTX_RA_GRP_ENTRY(pTable, CurrRateIdx);
+	pLastTxRate = PTX_RA_GRP_ENTRY(pTable, pEntry->lastRateIdx);
 
 	Rssi = RTMPMaxRssi(pAd, pEntry->RssiSample.AvgRssi[0], pEntry->RssiSample.AvgRssi[1], pEntry->RssiSample.AvgRssi[2]);
 
@@ -969,23 +1205,64 @@
 	Rate1FailCount = TxInfo.Rate1FailCnt;
 	Rate1SuccessCnt = Rate1TxCnt - Rate1FailCount;
 
-	if (TxTotalCnt != 0)
-	{
-		Rate1ErrorRatio = 100 - ((Rate1SuccessCnt * 100) / TxTotalCnt);
+	if (TxTotalCnt != 0) {
+		RetryRatio = 100 - ((Rate1SuccessCnt * 100) / TxTotalCnt);
+	} else {
+		RetryRatio = 0;
 	}
-	else
-	{
+	
+	if (Rate1TxCnt != 0) {
+		Rate1ErrorRatio = 100 - ((Rate1SuccessCnt * 100) / Rate1TxCnt);
+	} else {
 		Rate1ErrorRatio = 0;
 	}
 
 	//HwAggRateIndex = TxInfo.RateIndex;
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("++++++++++++++++++++\n"));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("TxTotalCnt = %d\n", TxInfo.TxCount));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate1 Tx Cnt = %d\n", TxInfo.Rate1TxCnt));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate2 Tx Cnt = %d\n", TxInfo.Rate2TxCnt));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate3 Tx Cnt = %d\n", TxInfo.Rate3TxCnt));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate4 Tx Cnt = %d\n", TxInfo.Rate4TxCnt));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate5 Tx Cnt = %d\n", TxInfo.Rate5TxCnt));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate1 fail = %d\n", TxInfo.Rate1FailCnt));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate1ErrorRatio = %d\n", Rate1ErrorRatio));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("RetryRatio = %d\n", RetryRatio));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA), ("HwAggRateIndex = %d\n", TxInfo.RateIndex));
+	
+		if (((pCurrTxRate->Mode != MODE_CCK) && (TxTotalCnt <= RA_PROBING_ABORT_TX_CNT)) ||
+			((pCurrTxRate->Mode != MODE_CCK) && (Rate1TxCnt <= 5) && (Rate1ErrorRatio != 100)) ||
+			((pCurrTxRate->Mode == MODE_CCK) && (pCurrTxRate->CurrMCS <= MCS_1) && (TxTotalCnt <= RA_PROBING_ABORT_CCK_TX_CNT)))
+		{
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL,(DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: Probe Failing, return to last rate.\n"));
+			MlmeRestoreLastRate(pEntry);
+			MlmeNewTxRate(pAd, pEntry);
+			return;
+		}
+	
+		if (Rate1ErrorRatio < 7)
+			bNoiseEnv = FALSE;
+		else if (Rate1ErrorRatio < 12) {
+			if (RetryRatio > (Rate1ErrorRatio * 3))
+				bNoiseEnv = TRUE;
+			else
+				bNoiseEnv = FALSE;
+		} else {
+			if (RetryRatio > (Rate1ErrorRatio * 2))
+				bNoiseEnv = TRUE;
+			else
+				bNoiseEnv = FALSE;
+		}
+	
+		u4CurrEffectTPut = pCurrTxRate->dataRate * (100 - Rate1ErrorRatio);
+		u4LastEffectTPut = pLastTxRate->dataRate * (100 - pEntry->LastTxPER);
 
 #ifdef MFB_SUPPORT
 	if (pEntry->fLastChangeAccordingMfb == TRUE)
 	{
 		pEntry->fLastChangeAccordingMfb = FALSE;
 		pEntry->LastSecTxRateChangeAction = RATE_NO_CHANGE;
-		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
 		/*  reset all OneSecTx counters */
 		RESET_ONE_SEC_TX_CNT(pEntry);
 		return;
@@ -993,8 +1270,8 @@
 #endif	/*  MFB_SUPPORT */
 
 	/*  Remember the current rate */
-	CurrRateIdx = pEntry->CurrTxRateIndex;
-	pCurrTxRate = PTX_RA_GRP_ENTRY(pTable, CurrRateIdx);
+	//CurrRateIdx = pEntry->CurrTxRateIndex;
+	//pCurrTxRate = PTX_RA_GRP_ENTRY(pTable, CurrRateIdx);
 
 #ifdef DOT11_N_SUPPORT
      /*
@@ -1008,9 +1285,46 @@
 	else
 #endif /*  DOT11_N_SUPPORT */
 	{
+		if (Rssi > -65)
+		{
+
+			TrainDown	= (pCurrTxRate->TrainDown + (pCurrTxRate->TrainDown >> 1));
+		}
+		else {
+
 		TrainDown	= pCurrTxRate->TrainDown;
+		}
 	}
 
+#if 1
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),(
+			"DRS:Wcid=%d, Rate1SuccessCnt=%d, Rate1FailCount=%d, TxTotalCnt=%d, ",
+			pEntry->wcid, Rate1SuccessCnt, Rate1FailCount, TxTotalCnt));
+
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), (
+		"rssi=[%d, %d, %d];;;pEntry->LastSecTxRateChangeAction=%d\n",
+		pEntry->RssiSample.AvgRssi[0], pEntry->RssiSample.AvgRssi[1], pEntry->RssiSample.AvgRssi[2], pEntry->LastSecTxRateChangeAction));
+
+
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), (
+			"   QuickDRS: CurrRateIdx=%d, MCS=%d %c, STBC=%d, SGI=%d, Mode=%d, TrainDown=%d, PER=%d, CurrEffectTP=%d, TP=%d\n",
+			CurrRateIdx,
+			pEntry->HTPhyMode.field.MCS,
+			pEntry->HTPhyMode.field.eTxBF? 'E': (pEntry->HTPhyMode.field.iTxBF? 'I': '-'),
+			pEntry->HTPhyMode.field.STBC,
+			pEntry->HTPhyMode.field.ShortGI,
+			pCurrTxRate->Mode,
+			TrainDown,
+			Rate1ErrorRatio,
+			u4CurrEffectTPut,
+			(100-Rate1ErrorRatio)*TxTotalCnt*pAd->ra_interval/(100*pAd->ra_fast_interval))); /*	Normalized packets per RA Interval */
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), (
+			"\t LastRateIdx=%d, LastTxPER=%d, LastPyhRate=%d, LastEffectTPut=%d\n",		
+			pEntry->lastRateIdx,
+			pEntry->LastTxPER,
+			pLastTxRate->dataRate,
+			u4LastEffectTPut));		
+#endif 
 
 #ifdef DBG_CTRL_SUPPORT
 	/*  Debug option: Concise RA log */
@@ -1025,7 +1339,7 @@
 	{
 		/*  Go back to the original rate */
 		MlmeRestoreLastRate(pEntry);
-		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("   QuickDRS: TxTotalCnt <= 15, back to original rate \n"));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("   QuickDRS: TxTotalCnt <= 15, back to original rate \n"));
 
 		MlmeNewTxRate(pAd, pEntry);
 
@@ -1035,21 +1349,21 @@
 		return;
 	}
 
-	if ( (TxTotalCnt <= 15) && (pEntry->LastSecTxRateChangeAction == RATE_DOWN))
-	{
-		return;
-	}
+	//if ( (TxTotalCnt <= 15) && (pEntry->LastSecTxRateChangeAction == RATE_DOWN))
+	//{
+	//	return;
+	//}
 
-	TxErrorRatio = Rate1ErrorRatio;
+	//TxErrorRatio = Rate1ErrorRatio;
 
 	/*
 		Compare throughput.
 		LastTxCount is based on a time interval of 500 msec or "500 - pAd->ra_fast_interval" ms.
 	*/
 	if (pEntry->LastTimeTxRateChangeAction == RATE_NO_CHANGE)
-		ratio = RA_INTERVAL / pAd->ra_fast_interval;
+		ratio = pAd->ra_interval / pAd->ra_fast_interval;
 	else
-		ratio = (RA_INTERVAL - pAd->ra_fast_interval) / pAd->ra_fast_interval;
+		ratio = (pAd->ra_interval - pAd->ra_fast_interval) / pAd->ra_fast_interval;
 
 /*
 	if (pAd->MacTab.Size == 1)
@@ -1062,16 +1376,17 @@
 
 	/* Downgrade TX quality if PER >= Rate-Down threshold */
 	/* the only situation when pEntry->TxQuality[CurrRateIdx] = DRS_TX_QUALITY_WORST_BOUND but no rate change */
-	if (TxErrorRatio >= TrainDown)
+	if (Rate1ErrorRatio >= TrainDown)
 		MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND);
 
-	pEntry->PER[CurrRateIdx] = (UCHAR)TxErrorRatio;
+	pEntry->PER[CurrRateIdx] = (UCHAR)Rate1ErrorRatio;
 
 
 	/*  Perform DRS - consider TxRate Down first, then rate up. */
 	if (pEntry->LastSecTxRateChangeAction == RATE_UP)
 	{
-		BOOLEAN useOldRate;
+		BOOLEAN useOldRate = FALSE;
+#if 0
 
 		// TODO: gaa - Finalize the decision criterion
 		/*
@@ -1100,13 +1415,31 @@
 		}
 		else
 			useOldRate = TxErrorRatio >= TrainDown;
+#else
+		if (u4CurrEffectTPut < u4LastEffectTPut)
+				useOldRate = TRUE;
+		
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), (" QuickDRS: useOldRate=%d, (C_TPUT:%d, L_PUT:%d)\n",
+				useOldRate, u4CurrEffectTPut, u4LastEffectTPut));
+#endif
+
 		if (useOldRate)
 		{
-			/*  If PER>50% or TP<lastTP/2 then double the TxQuality delay */
-			if ((TxErrorRatio > 50) || (OneSecTxNoRetryOKRationCount < pEntry->LastTxOkCount/2))
-				MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND*2);
+			if (bNoiseEnv)
+			{
+				if (Rate1ErrorRatio > 50)
+					MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND + DRS_TX_QUALITY_HALF_BOUND);
+				else
+					MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND);
+			}
 			else
-				MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND);
+			{
+				if ((Rate1ErrorRatio > 50) || (OneSecTxNoRetryOKRationCount < pEntry->LastTxOkCount/2))
+					MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND * 2);
+				else
+					MlmeSetTxQuality(pEntry, CurrRateIdx, DRS_TX_QUALITY_WORST_BOUND);
+			}
+
 
 			MlmeRestoreLastRate(pEntry);
 		}
@@ -1122,29 +1455,48 @@
 			if (pEntry->mcsGroup == 0)
 				MlmeSetMcsGroup(pAd, pEntry);
 
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),
 						("   QuickDRS: (Up) keep rate-up (L:%ld, C:%ld)\n",
 						pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
 		}
 	}
 	else if (pEntry->LastSecTxRateChangeAction == RATE_DOWN)
 	{
-		if ((TxErrorRatio >= 50) || (TxErrorRatio >= TrainDown)) /* there will be train down again */
+	#if 0
+		if (bNoiseEnv)
 		{
-			MlmeSetMcsGroup(pAd, pEntry);
-			MlmeSetTxQuality(pEntry, pEntry->CurrTxRateIndex, DRS_TX_QUALITY_WORST_BOUND);
-			pEntry->CurrTxRateIndex = pCurrTxRate->downMcs;
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("   QuickDRS: (Down) direct train down (TxErrorRatio >= TrainDown)\n"));
+			if (Rate1ErrorRatio >= (pEntry->LastTxPER - 3))
+			{
+				MlmeRestoreLastRate(pEntry);
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("   QuickDRS: (Down) Train down fail (L PER:%d, C PER:%d)\n", pEntry->LastTxPER, Rate1ErrorRatio));
+			}
 		}
-		else if ((pEntry->LastTxOkCount + 2) >= OneSecTxNoRetryOKRationCount)
+		else if (((pEntry->LastTxOkCount + 2) >= OneSecTxNoRetryOKRationCount) && 
+			(Rate1ErrorRatio != 100) && (pEntry->LastTxPER != 100))
 		{
 			MlmeRestoreLastRate(pEntry);
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("   QuickDRS: (Down) bad tx ok count (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("   QuickDRS: (Down) bad tx ok count (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
 		}
+#else
+		if ((u4CurrEffectTPut < u4LastEffectTPut) && (Rate1ErrorRatio < 100))
+		{
+			MlmeRestoreLastRate(pEntry);
+			{
+				int i = 0;
+				for ( i = 0; i < 10; i++) {
+					if ((pEntry->rxv2_cyc3[i] & 0xff) > pEntry->SwiftTrainThrd ) {
+						pEntry->bSwiftTrain = TRUE;
+						break;
+					}
+				}
+			}
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("   QuickDRS: (Down) Train down fail (C_TPUT:%d, L_PUT:%d)\n", u4CurrEffectTPut, u4LastEffectTPut));
+		}
+#endif
 		else
 		{
 			MlmeSetMcsGroup(pAd, pEntry);
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("   QuickDRS: (Down) keep rate-down (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("   QuickDRS: (Down) keep rate-down (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
 		}
 	}
 
@@ -1186,7 +1538,10 @@
 	if (rateChanged)
 	{
 		/*  Clear Old Rate's TxQuality */
+		if (pEntry->LastSecTxRateChangeAction == RATE_UP)
 		MlmeSetTxQuality(pEntry, pEntry->CurrTxRateIndex, 0);
+		else
+			MlmeSetTxQuality(pEntry, pEntry->CurrTxRateIndex, DRS_TX_QUALITY_HALF_BOUND);
 
 		pEntry->TxRateUpPenalty = 0;	/* redundant */
 		pEntry->PER[pEntry->CurrTxRateIndex] = 0;	/* redundant */
@@ -1205,7 +1560,8 @@
 	UCHAR UpRateIdx, DownRateIdx, CurrRateIdx, TrainUp, TrainDown;
 	RTMP_RA_GRP_TB *pCurrTxRate;
 	PUCHAR pTable = pEntry->pTable;
-	UCHAR Rate1ErrorRatio = 0, HwAggRateIndex = 0;
+	UCHAR Rate1ErrorRatio = 0, RetryRatio = 0;
+	UCHAR HwAggRateIndex = 0;
 	UINT32 Rate1TxCnt, Rate1SuccessCnt, Rate1FailCount, TxTotalCnt;
 
 	TxTotalCnt = Rate1TxCnt = Rate1SuccessCnt = Rate1FailCount = 0;
@@ -1216,19 +1572,31 @@
 	Rate1SuccessCnt = Rate1TxCnt - Rate1FailCount;
 
 	ASSERT(TxTotalCnt != 0);
-	Rate1ErrorRatio = 100 - ((Rate1SuccessCnt * 100) / TxTotalCnt);
+	if (TxTotalCnt != 0) {
+		RetryRatio = 100 - ((Rate1SuccessCnt * 100) / TxTotalCnt);
+	} else {
+		return;
+	}
+
+	if (Rate1TxCnt != 0) {
+		Rate1ErrorRatio = 100 - ((Rate1SuccessCnt * 100) / Rate1TxCnt);
+	} else {
+		return;
+	}
 
 	HwAggRateIndex = pTxInfo->RateIndex;
 
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("TxTotalCnt = %d\n", TxTotalCnt));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Rate1 Tx Cnt = %d\n", pTxInfo->Rate1TxCnt));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Rate2 Tx Cnt = %d\n", pTxInfo->Rate2TxCnt));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Rate3 Tx Cnt = %d\n", pTxInfo->Rate3TxCnt));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Rate4 Tx Cnt = %d\n", pTxInfo->Rate4TxCnt));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Rate5 Tx Cnt = %d\n", pTxInfo->Rate5TxCnt));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Rate1 fail = %d\n", pTxInfo->Rate1FailCnt));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Rate1ErrorRatio = %d\n", Rate1ErrorRatio));
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("HwAggRateIndex = %d\n", HwAggRateIndex));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("====================\n"));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("TxTotalCnt = %d\n", TxTotalCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate1 Tx Cnt = %d\n", pTxInfo->Rate1TxCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate2 Tx Cnt = %d\n", pTxInfo->Rate2TxCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate3 Tx Cnt = %d\n", pTxInfo->Rate3TxCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate4 Tx Cnt = %d\n", pTxInfo->Rate4TxCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate5 Tx Cnt = %d\n", pTxInfo->Rate5TxCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate1 fail = %d\n", pTxInfo->Rate1FailCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Rate1ErrorRatio = %d\n", Rate1ErrorRatio));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("RetryRatio = %d\n", RetryRatio));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("HwAggRateIndex = %d\n", HwAggRateIndex));
 
 	/*
 		After pEntry->fLastSecAccordingRSSI = TRUE; the for loop
@@ -1258,8 +1626,16 @@
 	pCurrTxRate = PTX_RA_GRP_ENTRY(pTable, CurrRateIdx);
 	UpRateIdx = MlmeSelectUpRate(pAd, pEntry, pCurrTxRate);
 	DownRateIdx = MlmeSelectDownRate(pAd, pEntry, CurrRateIdx);
+	if (((Rate1ErrorRatio == 100) && (Rate1TxCnt < 20) && (pTxInfo->Rate1TxCnt == pTxInfo->Rate2TxCnt))||
+		(pEntry->bSwiftTrain && (MlmeSelectDownRate(pAd, pEntry, DownRateIdx) >= MCS_8))) {
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("SwiftTrain Hit!\n"));
+		pEntry->bSwiftTrain = FALSE;
+		DownRateIdx = MlmeSelectDownRate(pAd, pEntry, DownRateIdx);
+		if (pTxInfo->Rate1TxCnt == pTxInfo->Rate3TxCnt)
+			DownRateIdx = MlmeSelectDownRate(pAd, pEntry, DownRateIdx);
+	}
 
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Average PER %d, Cur %x, Up %x, Dn %x\n", Rate1ErrorRatio
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Average PER %d, Cur %x, Up %x, Dn %x\n", Rate1ErrorRatio
 								, CurrRateIdx, UpRateIdx, DownRateIdx));
 
 #ifdef DOT11_N_SUPPORT
@@ -1278,8 +1654,12 @@
 		TrainUp = pCurrTxRate->TrainUp;
 		TrainDown = pCurrTxRate->TrainDown;
 	}
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("TrainUp=%d, TrainDown=%d, mcsG=%d, TxQ=%d, TxQ_up=%d\n",
+							TrainUp, TrainDown, pEntry->mcsGroup, 
+							MlmeGetTxQuality(pEntry, CurrRateIdx),MlmeGetTxQuality(pEntry, UpRateIdx)));
 
 	pEntry->PER[CurrRateIdx] = (UCHAR)Rate1ErrorRatio;
+	pEntry->LastTxPER = Rate1ErrorRatio;
 
 	NewRateAdaptMT(pAd, pEntry, UpRateIdx, DownRateIdx, TrainUp, TrainDown,
 		Rate1ErrorRatio, HwAggRateIndex);
@@ -1508,6 +1888,47 @@
 		RESET_ONE_SEC_TX_CNT(pEntry);
 	}
 }
+#ifdef ANTI_INTERFERENCE_SUPPORT
+VOID DynamicRaInterval(RTMP_ADAPTER *pAd)
+{
+	ULONG irqFlags = 0;
+	UINT32 ampdu_fail_cnt;
+	UINT32 ampdu_fail_ratio;
+
+	if (pAd->RalinkCounters.OneSecTxAMpduCnt > 50) {
+
+		ampdu_fail_cnt = pAd->RalinkCounters.OneSecTxAMpduCnt - pAd->RalinkCounters.OneSecTxBACnt;
+		ampdu_fail_ratio = (ampdu_fail_cnt * 100) / pAd->RalinkCounters.OneSecTxAMpduCnt;
+
+		if (ampdu_fail_ratio > 50) {
+			pAd->ra_interval_extend = 3;
+			
+			if(pAd->ra_interval == DEF_RA_TIME_INTRVAL)
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, DBG_LVL_OFF,
+				("%s();Change ra_interval/ra_fast_interval = 1000ms/300ms \n",__FUNCTION__));
+			
+			RTMP_IRQ_LOCK(&pAd->irq_lock, irqFlags);
+			pAd->ra_interval = 1000;
+			pAd->ra_fast_interval = 300;
+
+			RTMP_IRQ_UNLOCK(&pAd->irq_lock, irqFlags);
+
+			return;
+		}
+	}
+
+	if (pAd->ra_interval_extend > 0)
+		pAd->ra_interval_extend--;
+	
+	if ( pAd->ra_interval_extend == 0) {
+		RTMP_IRQ_LOCK(&pAd->irq_lock, irqFlags);
+		pAd->ra_interval = DEF_RA_TIME_INTRVAL;
+		pAd->ra_fast_interval = DEF_QUICK_RA_TIME_INTERVAL;
+		pAd->ra_interval_extend = -1;
+		RTMP_IRQ_UNLOCK(&pAd->irq_lock, irqFlags);
+	}
+}
+#endif /* ANTI_INTERFERENCE_SUPPORT */
 
 #endif /* MT_MAC */
 
@@ -1606,7 +2027,7 @@
 				else
 					HwErrRatio = 0;
 
-				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("%s()=>Wcid:%d, MCS:%d, TxErrRation(Hw:0x%lx-0x%lx, Sw:0x%lx-%lx)\n",
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("%s()=>Wcid:%d, MCS:%d, TxErrRation(Hw:0x%lx-0x%lx, Sw:0x%lx-%lx)\n",
 						__FUNCTION__, pEntry->wcid, pEntry->HTPhyMode.field.MCS,
 						HwTxCnt, HwErrRatio, TxTotalCnt, TxErrorRatio));
 
@@ -1622,14 +2043,14 @@
 	}
 
 
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Quick PER %lu, Total Cnt %lu\n", TxErrorRatio, TxTotalCnt));
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Quick PER %lu, Total Cnt %lu\n", TxErrorRatio, TxTotalCnt));
 
 #ifdef MFB_SUPPORT
 	if (pEntry->fLastChangeAccordingMfb == TRUE)
 	{
 		pEntry->fLastChangeAccordingMfb = FALSE;
 		pEntry->LastSecTxRateChangeAction = RATE_NO_CHANGE;
-		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
 		/*  reset all OneSecTx counters */
 		RESET_ONE_SEC_TX_CNT(pEntry);
 		return;
@@ -1665,7 +2086,7 @@
 	{
 		/*  Go back to the original rate */
 		MlmeRestoreLastRate(pEntry);
-		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("   QuickDRS: TxTotalCnt <= 15, back to original rate \n"));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("   QuickDRS: TxTotalCnt <= 15, back to original rate \n"));
 
 		MlmeNewTxRate(pAd, pEntry);
 
@@ -1751,7 +2172,7 @@
 			if (pEntry->mcsGroup == 0)
 				MlmeSetMcsGroup(pAd, pEntry);
 
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),
 						("   QuickDRS: (Up) keep rate-up (L:%ld, C:%ld)\n",
 						pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
 		}
@@ -1761,17 +2182,17 @@
 		if ((TxErrorRatio >= 50) || (TxErrorRatio >= TrainDown)) /* there will be train down again */
 		{
 			MlmeSetMcsGroup(pAd, pEntry);
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("   QuickDRS: (Down) direct train down (TxErrorRatio >= TrainDown)\n"));
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("   QuickDRS: (Down) direct train down (TxErrorRatio >= TrainDown)\n"));
 		}
 		else if ((pEntry->LastTxOkCount + 2) >= OneSecTxNoRetryOKRationCount)
 		{
 			MlmeRestoreLastRate(pEntry);
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("   QuickDRS: (Down) bad tx ok count (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("   QuickDRS: (Down) bad tx ok count (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
 		}
 		else
 		{
 			MlmeSetMcsGroup(pAd, pEntry);
-			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("   QuickDRS: (Down) keep rate-down (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
+			MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("   QuickDRS: (Down) keep rate-down (L:%ld, C:%ld)\n", pEntry->LastTxOkCount, OneSecTxNoRetryOKRationCount));
 		}
 	}
 
@@ -1895,7 +2316,7 @@
 					HwErrRatio = (pEntry->fifoTxRtyCnt * 100) / HwTxCnt;
 				else
 					HwErrRatio = 0;
-				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("%s()=>Wcid:%d, MCS:%d, TxErrRatio(Hw:0x%lx-0x%lx, Sw:0x%lx-%lx)\n",
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("%s()=>Wcid:%d, MCS:%d, TxErrRatio(Hw:0x%lx-0x%lx, Sw:0x%lx-%lx)\n",
 						__FUNCTION__, pEntry->wcid, pEntry->HTPhyMode.field.MCS,
 						HwTxCnt, HwErrRatio, TxTotalCnt, TxErrorRatio));
 
@@ -1923,7 +2344,7 @@
 	UpRateIdx = MlmeSelectUpRate(pAd, pEntry, pCurrTxRate);
 	DownRateIdx = MlmeSelectDownRate(pAd, pEntry, CurrRateIdx);
 
-	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA), ("Average PER %lu, Cur %x, Up %x, Dn %x\n", TxErrorRatio,
+	MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA), ("Average PER %lu, Cur %x, Up %x, Dn %x\n", TxErrorRatio,
 								CurrRateIdx, UpRateIdx, DownRateIdx));
 
 #ifdef DOT11_N_SUPPORT
@@ -1963,7 +2384,7 @@
 		pEntry->LastSecTxRateChangeAction = RATE_NO_CHANGE;
 		NdisReleaseSpinLock(&pEntry->fLastChangeAccordingMfbLock);
 		APMlmeSetTxRate(pAd, pEntry, pEntry->LegalMfbRS);
-		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
 		MlmeClearAllTxQuality(pEntry); /* clear all history, same as train up, purpose??? */
 		/*  reset all OneSecTx counters */
 		RESET_ONE_SEC_TX_CNT(pEntry);
@@ -2013,7 +2434,7 @@
 			MlmeNewTxRate(pAd, pEntry);
 			if (!pEntry->fLastSecAccordingRSSI)
 			{
-				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: TxTotalCnt <= 15, switch to MCS%d according to RSSI (%d), RssiOffset=%d\n", pEntry->HTPhyMode.field.MCS, Rssi, RssiOffset));
+				MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: TxTotalCnt <= 15, switch to MCS%d according to RSSI (%d), RssiOffset=%d\n", pEntry->HTPhyMode.field.MCS, Rssi, RssiOffset));
 			}
 
 			MlmeClearAllTxQuality(pEntry);	/* clear all history */
@@ -2117,7 +2538,7 @@
 	{
 		pEntry->fLastChangeAccordingMfb = FALSE;
 		pEntry->LastSecTxRateChangeAction = RATE_NO_CHANGE;
-		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
+		MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: MCS is according to MFB, and ignore tuning this sec \n"));
 
 		/* reset all OneSecTx counters */
 		RESET_ONE_SEC_TX_CNT(pEntry);
@@ -2495,7 +2916,7 @@
 				MlmeNewTxRate(pAd, pEntry);
 				if (!pEntry->fLastSecAccordingRSSI)
 				{
-					MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_INFO | DBG_FUNC_RA),("DRS: TxTotalCnt <= 15, switch to MCS%d according to RSSI (%d), RssiOffset=%d\n", pEntry->HTPhyMode.field.MCS, Rssi, RssiOffset));
+					MTWF_LOG(DBG_CAT_ALL, DBG_SUBCAT_ALL, (DBG_LVL_TRACE | DBG_FUNC_RA),("DRS: TxTotalCnt <= 15, switch to MCS%d according to RSSI (%d), RssiOffset=%d\n", pEntry->HTPhyMode.field.MCS, Rssi, RssiOffset));
 				}
 			}
 
diff -Nru old/src/rate_ctrl/ra_ctrl.c new/src/rate_ctrl/ra_ctrl.c
--- old/src/rate_ctrl/ra_ctrl.c	2016-03-10 11:12:00.000000000 +0800
+++ new/src/rate_ctrl/ra_ctrl.c	2019-03-11 10:36:33.342311100 +0800
@@ -346,7 +346,7 @@
 	 7, 0x21,  7,  8,  14,   6,    8,     8,   8,  65,/* mcs7 */
 	 8, 0x23,  7,  8,  14,   7,    8,     8,   8,  72,/* mcs7+short gi */
 
-	 9, 0x00,  0, 40,  101,  9,   10,    10,  10,   1, /* cck-1M */
+	 9, 0x00,  0, 40,  101,  9,   11,    11,  11,   1, /* cck-1M */
 	10, 0x00,  1, 40,  50,   9,   11,    11,  11,   2, /* cck-2M */
 	11, 0x10, 0,  30,  50,  10,    0,     0,   0,   6, /* OFDM 6M */	
 };
@@ -395,7 +395,7 @@
 	17, 0x22, 15,  8,  25,  16,   17,  17,  17, 144,/* mcs15+shortGI */
     18,    0,  0,  0,   0,   0,   0,    0,   0,   0,
 #endif
-    19, 0x00,  0, 40,  101, 19 ,  19,    19,   20,  1, /* cck-1M */
+    19, 0x00,  0, 40,  101, 19 ,  19,    19,   21,  1, /* cck-1M */
     20, 0x00,  1, 40,  50,  19,   20,    20,   21,  2, /* cck-2M */
     21, 0x10,  0, 30,  50,  20,   8,     8,    0,   6, /* OFDM 6M */
 };
@@ -2322,6 +2322,10 @@
 	pEntry->LastSecTxRateChangeAction = RATE_NO_CHANGE;
 	pEntry->CurrTxRateIndex = 0;
 	pEntry->TxRateUpPenalty = 0;
+    pEntry->SwiftTrainThrd = 10;
+#if (SWIFT_TRAIN_UP >= 1)
+        ra_swift_train_up_table_reset(pEntry);
+#endif
 
 	MlmeClearAllTxQuality(pEntry);
 }
